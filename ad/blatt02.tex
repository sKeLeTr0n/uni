\documentclass[a4paper,fleqn]{scrartcl}
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{enumerate}
\usepackage{scrpage2}
\usepackage{tikz}

\ihead{AD Übung 2}

\ohead{Arne Feil (6325495), Markus Deecke (6342721)}
\pagestyle{scrheadings}
\setheadsepline{1pt}
\newcommand{\qed}{\quad \square}

\begin{document}
\section{Aufgabe}
\begin{enumerate}[a)]
 \item
 \[ T(n):= \begin{cases}
    c_0 & n < 3 \\ 
    2T\left( \frac{n}{3} \right) N \cdot \log(n) + c_1 & \text{sonst}
   \end{cases}\] \\
   Begründung: \\
 \item
 \begin{enumerate}[(a)]
  \item \[ T(n) = 16 T\Big(\frac n 4\Big) + n^2 \]
\[ T(n) = 16 \Big[T(\frac {\frac n 4} 4) + (\frac n 4)^2 \Big] + n^2\]
\[ T(n) = 16^i T(\frac n {4^i} + i \cdot n^2\]
\[ \frac n {4^i} \leq 1 \Leftrightarrow n \leq 4^i \Leftrightarrow \log_4 n \leq i \]
\begin{align*}
T(n) &= 16^i T(\frac n {4^i}) + i \cdot n^2\\
     &\leq 16^{\log_4 n} \cdot T(1) + \log_4 n^2\\
     &= 4^{\log_4 n} \cdot 4^{\log_4 n} \cdot c + \log_4 n n^2\\
     &= n \cdot n \cdot c + \log_4 n n^2\\
     &= n^2 (c + \log_4 n) = O(n^2)
\end{align*}
  \item \[ T(n) = 16 \cdot T\left( \frac{n}{4} \right) + n^2 \]
\[ a= 16 \quad b = 4 \]
\[ f(n) \in \Theta \left( n^{\log_b a} \right) \]
\[ n^2 \in \Theta \left( n^{\log_4 16=2} \right) \]
\[ \Theta \left(n^2 \cdot \log(n)\right) \]
 \end{enumerate}

 \item 
 \begin{enumerate}[1.]
  \item 
  \item $ n^{\log_b a} $
 \end{enumerate}

\end{enumerate}
 
\section{Aufgabe}
\begin{enumerate}[1.]
\item vla
\item Zu zeigen ist, dass der Algorithmus korrekt ist. Wir zeigen dies nach
Cormen mit den 3 Schritten: "Initialization", "Maintenance", "Termination".
Unsere Invariante ist: Das Subarray \(A[1..j-1]\) besteht aus den Elementen, die
Ursprünglich in \(A[1..j-1]\), aber in sortierter Reihenfolge.
\begin{enumerate}[(a)]
\item Initilization: Zuerst prüfen wir, ob das Subarray \(A[1..i]\) vor der
ersten Iteration aus dem originalen Array \(A^{orig}[1..i]\) besteht und
nur sortiert ist.
\[i = 1 \Rightarrow A[i] = A^{orig}[i] \Rightarrow Initilization\ ist\ korrekt\]
\item Maintenance: Jetzt zeigen wir, dass der Algorithmus auch für weitere Schritte gilt.
Der Körper der Schleifen des Sorts funktioniert so:
\begin{enumerate}
\item Das Element A[i] macht einen Schritt nach rechts.
\item Das geht bis die gültige Position für A[i] gefunden ist.
\item Dann besteht das Subarray A[1..i] aus den Elementen \(A^{orig}[1..i]\) (aber sortiert)
\end{enumerate}
\[\Rightarrow Maintenance\ ist\ korrekt\]
\item Termination: Der Algorithmus terminiert, wenn \(i=A.length = n\).
Dann ist \(A[1..i] = A[1..n] \geq A^{orig}[1..n]\), aber sortiert.
\[\Rightarrow Termination\ ist\ korrekt\]
\end{enumerate}
Wenn alle drei Fälle korrekt sind, ist der Algorithmus korrekt.

\end{enumerate}

\end{document}